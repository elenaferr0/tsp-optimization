#import "../glossary.typ": defs
#import "@preview/glossy:0.8.0": init-glossary

#show : init-glossary.with(defs)

= Introduction
This report presents two approaches which were implemented to solve the @TSP:both: an exact method and a genetic algorithm. More specifically, this project positions itself in the context of @PCB:pl production, where the goal is to find the shortest path for a drill to take when boring holes in a board.

== Project structure and usage
The project contains two folders corresponding to the two implemented approaches. Both parts contain an `include` directory for header files, a `samples` directory for input instances, and a `src` directory for the source code. The root directory also contains `random_instance_gen.py`, a script for generating random instances of the problem. Given that solutions are generated differently for the two approaches, each part has its own `plot.py` script to visualize the results.

For the sake of simplicity, these scripts have been written in Python, in order to leverage its plotting libraries and simplify the generation of instances.

Below is the structure of the project:
```
  ├── part_one
  │   ├── include
  │   ├── samples
  │   ├── src
  │   └── plot.py
  ├─── part_two
  │   ├── include
  │   ├── samples
  │   ├── src
  │   └── plot.py
  └─── random_instance_gen.py
```

=== File formats
#text("TODO: dat and solution files", red, size: 18pt)

=== Running part one
The following commands assume the user is initially positioned in the root directory of the project. The first part can be run with the following commands:

```bash
cd part_one
make
./main <instance> [formulation] [timeout]
```

Where `<instance>` is the path to the input instance, `formulation` is an optional parameter that can be either `gg` for Gavish and Graves' formulation or `mtz` for Miller, Tucker and Zemlin's formulation. `timeout` is an optional parameter that limits the maximum time in seconds to run the algorithm. If no timeout is specified, the algorithm will run until completion.

After running the algorithm, a `.sol` solution file will be generated in the same directory as the input instance, named as `<instance>_<formulation>.sol`. This file contains the solution to the problem, which can be visualized using the provided `plot.py` script.

Example of usage with a Gavish and Graves' formulation on an instance named `random_10.dat` with a timeout of 60 seconds:
```bash
./main samples/random_10.dat gg 60
```
The solution will be saved in `samples/random_10_gg.sol`. 

==== Plot visualization
To visualize the solution, the `plot.py` script can be used. It takes the following arguments:
```bash
plot.py [-h] -d DAT [-s SOL] [-o OUTPUT]
```
Where `-d DAT` is the path to the input instance file, `-s SOL` is the path to the solution file (optional), and `-o OUTPUT` is the output file for the plot (optional). If no output file is specified, the plot will be displayed on screen.
To visualize the solution generated in the previous step, one would run:
```bash
py plot.py -d ./samples/random_10.dat -s ./samples/random_10_gg.sol
```
This will produce an image showing the holes in the instance and the path taken by the drill to bore them, as well as the total distance traveled. The image will be saved in the same directory as the input instance, named as `<instance>_tour.png`.

The plot script can also be used to visualize the input instance without a solution file, in which case it will only show the holes in the instance. To achieve this, it's sufficient to run:
```bash
py plot.py -d ./samples/random_10.dat
```

=== Running part two
Analogous procedure can be followed for the second part of the project. The commands to run the second part are as follows:
```bash
cd part_two
make
./main <instance>
```

Note that the second part will already run the genetic algorithm with the tuned parameters, so no additional arguments are needed. The solution will be saved in the same directory as the input instance, named as `<instance>_sol.dat`.

==== Plot visualization
To visualize the solution generated by the genetic algorithm, the `plot.py` script can be used identically to the first part. An example of usage is as follows:
```bash
py plot.py -d ./samples/random_10.dat -s ./samples/random_10_sol.dat
```
This will produce an image showing the holes in the instance and the path taken by the drill to bore them, as well as the total distance traveled. The image will be saved in the same directory as the input instance, named as `<instance>_tour.png`.

== Problem instances
In order to test the implemented algorithms, a set of random instances was generated. Each consists of a number of holes represented as points in a 2D plane. The distance is computed using the Euclidean distance formula.

The goal is that of generating instances which are representative of real-world scenarios for @PCB production. To achieve this, points are generated according to one of the following patterns: 
- line: three to five points are aligned in a straight line, with either a uniform or non-uniform random distance between them. The line can be orientated in several directions, including diagonally;
- triangle: three points are randomly placed in a triangular shape, with varying size and orientation. These can also be irregular triangles;
- rectangle: four points are placed in a rectangular shape, with varying size and orientation;
- parallelogram: four points are placed in a parallelogram shape, with varying size, orientation and skewness.

Other than these, a few points are randomly created. During this generation process, a minimum distance between points and patterns is enforced, to avoid overlapping holes. A density parameter controls the sparsity, with a higher density resulting in more closely packed holes. Note that these patterns are, in general, not very visible for smaller instances, but they become more apparent as the number of holes increases. #ref(<fig:random-instance-eg>) shows an example of a random instance with 100 holes, with quite evident patterns.

#figure(
  image("../imgs/random_instance_eg.png", width: 60%),
  caption: "Example of a random instance with 100 holes.",
) <fig:random-instance-eg>

=== Script usage
The script used to generate random instances is available in the root directory of the project, under the name `random_instance_gen.py`. It can be run from the command line with the following syntax:
```bash
python3 random_instance_gen.py -s SIZE [-d DENSITY] -o OUTPUT_DIR
```
For instance, to generate a random instance with 100 holes and a density of 0.5, and save it in the `part_one/samples` directory, one would run:
```bash
python3 random_instance_gen.py -s 100 -d 0.5 -o part_one/samples
```